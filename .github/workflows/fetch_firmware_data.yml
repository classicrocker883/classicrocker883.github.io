name: Fetch Firmware Release Data

on:
  schedule:
    - cron: '22 12  1 * *'
    - cron: '22 12  8 * *'
    - cron: '22 12 18 * *'
    - cron: '22 12 28 * *'

  workflow_dispatch:

permissions:
  contents: write

jobs:
  fetch_data:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4.2.2

      - name: Setup Node.js
        uses: actions/setup-node@v4.4.0
        with:
          node-version: '20'

      - name: Fetch and save releases data
        run: |
          mkdir -p assets/data

          node -e '
            const fs = require("fs");
            const https = require("https");

            async function fetchPage(url) {
                return new Promise((resolve, reject) => {
                    https.get(url, {
                        headers: {
                            "User-Agent": "classicrocker883-firmware-selector"
                        }
                    }, (res) => {
                        let data = "";
                        res.on("data", (chunk) => { data += chunk; });
                        res.on("end", () => {
                            if (res.statusCode >= 200 && res.statusCode < 300) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(`Failed to fetch ${url}, Status: ${res.statusCode}, Message: ${data}`));
                            }
                        });
                    }).on("error", (err) => {
                        reject(err);
                    });
                });
            }

            async function fetchAllReleases(url, page = 1, releases = [], sinceDate = null) {
                let currentPageUrl = `${url}?page=${page}&per_page=100`;
                if (sinceDate) {
                    currentPageUrl += `&since=${sinceDate.toISOString()}`;
                }
                console.log(`Fetching page ${page} from: ${currentPageUrl}`);
                const data = await fetchPage(currentPageUrl);

                if (data.length === 0) {
                    return releases;
                }
                return fetchAllReleases(url, page + 1, releases.concat(data), sinceDate);
            }

            async function main() {
              const repoApiUrl = "https://api.github.com/repos/classicrocker883/MRiscoCProUI/releases";
              const filePath = "assets/data/releases.json";
              let existingReleases = [];

              if (fs.existsSync(filePath)) {
                  try {
                      existingReleases = JSON.parse(fs.readFileSync(filePath, "utf8"));
                      console.log(`Loaded ${existingReleases.length} existing releases from ${filePath}.`);
                  } catch (parseError) {
                      console.warn(`Could not parse existing releases.json (${parseError.message}), starting with an empty set for existing data.`);
                      existingReleases = [];
                  }
              } else {
                  console.log("No existing releases.json found.");
              }

              try {
                const fetchSinceDays = 30;
                const fetchSinceDate = new Date();
                fetchSinceDate.setDate(fetchSinceDate.getDate() - fetchSinceDays);
                console.log(`Will fetch releases published since: ${fetchSinceDate.toISOString()} (last ${fetchSinceDays} days).`);

                const recentlyPublishedReleases = await fetchAllReleases(repoApiUrl, 1, [], fetchSinceDate);
                console.log(`Fetched ${recentlyPublishedReleases.length} releases published in the last ${fetchSinceDays} days.`);

                const allReleasesMap = new Map();
                existingReleases.forEach(release => allReleasesMap.set(release.id, release));
                recentlyPublishedReleases.forEach(release => allReleasesMap.set(release.id, release));

                let combinedReleases = Array.from(allReleasesMap.values());
                console.log(`Total releases after merging: ${combinedReleases.length}.`);

                const historicalWindowYears = 1;
                const pruneDate = new Date();
                pruneDate.setFullYear(pruneDate.getFullYear() - historicalWindowYears);

                combinedReleases = combinedReleases.filter(release =>
                    new Date(release.published_at) >= pruneDate
                );
                console.log(`Pruned releases older than ${pruneDate.toISOString()}. Remaining: ${combinedReleases.length} releases in the file.`);

                combinedReleases.sort((a, b) => new Date(b.published_at) - new Date(a.published_at));

                if (!fs.existsSync("assets/data")) {
                    fs.mkdirSync("assets/data", { recursive: true });
                }
                fs.writeFileSync(filePath, JSON.stringify(combinedReleases, null, 2));
                console.log("Successfully updated and saved releases.json.");
              } catch (error) {
                console.error("Failed to fetch or save releases:", error.message);
                process.exit(1);
              }
            }
            main();
          '

      - name: Commit and push if changes
        run: |
          git config user.name "Andrew"
          git config user.email "andrewleduc88@yahoo.com"
          git add assets/data/releases.json
          git diff --cached --exit-code assets/data/releases.json || git commit -m "automated: Update firmware release data"
          git push
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
