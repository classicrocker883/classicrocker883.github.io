name: Fetch Firmware Release Data

on:
  schedule:
    - cron: '22 12 2,10,18,26 * *'

  workflow_dispatch:

permissions:
  contents: write

jobs:
  fetch_data:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 24

      - name: Fetch and save releases data
        env:
          GH_TOKEN: ${{ secrets.MYTOKEN }}
        run: |
          mkdir -p assets/data

          node -e '
            const fs = require("fs");
            const https = require("https");

            const PRUNE_WINDOW_MONTHS = 18;
            const PER_PAGE = 20;
            const pruneCutoff = new Date();
            pruneCutoff.setMonth(pruneCutoff.getMonth() - PRUNE_WINDOW_MONTHS);

            const sleep = (ms) => new Promise(res => setTimeout(res, ms));

            function cleanReleases(releases) {
                if (!Array.isArray(releases)) return [];
                return releases.map(release => {
                    const { body, author, mentions_count, tarball_url, zipball_url, ...clean } = release;
                    return clean;
                });
            }

            async function fetchPage(url, retries = 3) {
                for (let i = 0; i < retries; i++) {
                    try {
                        return await new Promise((resolve, reject) => {
                            const options = {
                                headers: {
                                    "User-Agent": "classicrocker883-firmware-selector",
                                    "Authorization": process.env.GH_TOKEN ? `token ${process.env.GH_TOKEN}` : ""
                                },
                                timeout: 20000
                            };
                            https.get(url, options, (res) => {
                                let data = "";
                                res.on("data", (chunk) => { data += chunk; });
                                res.on("end", () => {
                                    if (res.statusCode === 200) {
                                        resolve(JSON.parse(data));
                                    } else if (res.statusCode === 403) {
                                        reject(new Error("Rate limited or Forbidden. Check GH_TOKEN."));
                                    } else {
                                        reject(new Error(`Status: ${res.statusCode}`));
                                    }
                                });
                            }).on("error", reject);
                        });
                    } catch (err) {
                        if (i === retries - 1) throw err;
                        console.log(`[Retry ${i+1}] Error: ${err.message}. Retrying...`);
                        await sleep(3000 * (i + 1));
                    }
                }
            }

            async function fetchAllReleases(baseUrl) {
                let allReleases = [];
                let page = 1;
                console.log(`Pruning Cutoff Date: ${pruneCutoff.toISOString()}`);

                while (true) {
                    const url = `${baseUrl}?per_page=${PER_PAGE}&page=${page}`;
                    console.log(`Fetching Page ${page}...`);

                    const data = await fetchPage(url);
                    if (!data || data.length === 0) {
                        console.log("No more data found on GitHub.");
                        break;
                    }

                    allReleases = allReleases.concat(data);
                    const oldestInBatch = new Date(data[data.length - 1].published_at);
                    console.log(`  -> Page ${page} contains ${data.length} items. Oldest in batch: ${oldestInBatch.toISOString()}`);

                    if (oldestInBatch < pruneCutoff) {
                        console.log("  -> Reached 18-month cutoff. Stopping fetch.");
                        break;
                    }

                    if (data.length < PER_PAGE) {
                        console.log("  -> Last page reached (incomplete batch).");
                        break;
                    }

                    page++;
                    await sleep(1000);
                }
                return allReleases;
            }

            async function main() {
                const repoApiUrl = "https://api.github.com/repos/classicrocker883/MRiscoCProUI/releases";
                const filePath = "assets/data/releases.json";

                try {
                    if (!process.env.GH_TOKEN) console.warn("WARNING: No GH_TOKEN found. You may hit rate limits.");

                    const githubReleases = await fetchAllReleases(repoApiUrl);
                    let existingReleases = [];
                    if (fs.existsSync(filePath)) {
                        existingReleases = JSON.parse(fs.readFileSync(filePath, "utf8"));
                    }

                    const githubMap = new Map(githubReleases.map(r => [r.id, r]));
                    const finalMap = new Map();

                    existingReleases.forEach(rel => {
                        const pubDate = new Date(rel.published_at);
                        if (pubDate < pruneCutoff) {
                            finalMap.set(rel.id, rel);
                        } else if (githubMap.has(rel.id)) {
                            finalMap.set(rel.id, rel);
                        } else {
                            console.log(`[PRUNE] Ghost tag removed (Newer than 18mo but deleted from GH): ${rel.tag_name}`);
                        }
                    });

                    githubReleases.forEach(rel => finalMap.set(rel.id, rel));

                    const combined = Array.from(finalMap.values())
                        .sort((a, b) => new Date(b.published_at) - new Date(a.published_at));

                    fs.writeFileSync(filePath, JSON.stringify(cleanReleases(combined), null, 2));
                    console.log(`Success! Final count: ${combined.length} releases.`);
                } catch (error) {
                    console.error("Critical Error:", error.message);
                    process.exit(1);
                }
            }
            main();
          '

      - name: Commit and push if changes
        env:
          GH_TOKEN: ${{ secrets.MYTOKEN }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git remote set-url origin https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git
          git add assets/data/releases.json
          if git diff --cached --exit-code assets/data/releases.json; then
            echo "No changes to commit."
          else
            git commit -m "automated: update firmware release data"
            git push origin HEAD
            echo "Changes committed and pushed."
          fi
